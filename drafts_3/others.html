<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="2020-04-20 -&amp;gt; 2020-04-22 花了3天时间看和做lab1 , 通过了全部test 之前做过一个分布式的任务调度项目 , 所以在go并发相关的知识学习上没有花费太多时间 ,然后mapReduce概念就是之前做过的一道面试题的泛化 , 大文件小内存机子,单词数统计,所以3天时间完成还是比较开心的,但是稍微看了lab2,难度好像要大上不小 为了通过最后一个任务超时重新分配和wo">
<meta property="og:type" content="website">
<meta property="og:title" content="Log0c">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;drafts_3&#x2F;others.html">
<meta property="og:site_name" content="Log0c">
<meta property="og:description" content="2020-04-20 -&amp;gt; 2020-04-22 花了3天时间看和做lab1 , 通过了全部test 之前做过一个分布式的任务调度项目 , 所以在go并发相关的知识学习上没有花费太多时间 ,然后mapReduce概念就是之前做过的一道面试题的泛化 , 大文件小内存机子,单词数统计,所以3天时间完成还是比较开心的,但是稍微看了lab2,难度好像要大上不小 为了通过最后一个任务超时重新分配和wo">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2020-10-09T03:01:10.116Z">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/drafts_3/others">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: false,
    isPage: true,
    isArchive: false
  };
</script>

  <title> | Log0c
  </title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Log0c</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-posts">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Posts</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content">
            

  <div class="posts-expand">
    
    
    
    <div class="post-block" lang="en">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">
</h1>

<div class="post-meta">
  

</div>

</header>

      
      
      
      <div class="post-body">
          <p>2020-04-20 -&gt; 2020-04-22 花了3天时间看和做lab1 , 通过了全部test</p>
<p>之前做过一个分布式的任务调度项目 , 所以在go并发相关的知识学习上没有花费太多时间 ,<br>然后mapReduce概念就是之前做过的一道面试题的泛化 , 大文件小内存机子,单词数统计,<br>所以3天时间完成还是比较开心的,但是稍微看了lab2,难度好像要大上不小</p>
<p>为了通过最后一个任务超时重新分配和worker随机崩溃的测试 , 不得不整理和优化了一次worker和master的代码,看起来干净了许多</p>
<hr>
<p>title: MIT6.824 Lab1 / Lab2<br>date: 2020-06-12<br>tags: 基础补足</p>
<hr>
<p>…</p>
<a id="more"></a>

<p><a href="https://github.com/carlclone/MIT-6.824-LAB-2020" target="_blank" rel="noopener">6.824 github</a></p>
<h1 id="Lab1"><a href="#Lab1" class="headerlink" title="Lab1"></a>Lab1</h1><p>两个月之前写的了 , 之前没有看论文,直接看的 test case , 思路是参照<br>我之前写的go 分布式调度的方案 , worker 去向 master 轮询获取task ,<br>并且生成的中间输出相当于放在一个 GFS 中 , 和论文的框架不一致,<br>下一次重写的时候需要做到的一些点: </p>
<ul>
<li><input disabled="" type="checkbox"> 看完论文</li>
<li><input disabled="" type="checkbox"> event-driven</li>
<li><input disabled="" type="checkbox"> master 主动派发任务给 worker</li>
<li><input disabled="" type="checkbox"> 心跳监控 worker 的状态</li>
<li><input disabled="" type="checkbox"> 中间输出存储在每个 worker的本地 , 告知 master 地址 , master 派发任务的时候将多个中间输出一同告知 worker</li>
</ul>
<h1 id="Lab2"><a href="#Lab2" class="headerlink" title="Lab2"></a>Lab2</h1><p>经历了 3 次重写,跑 100 次可以稳定通过了</p>
<h1 id="rpc-实现目标"><a href="#rpc-实现目标" class="headerlink" title="rpc 实现目标"></a>rpc 实现目标</h1><p>java 客户端可通过实例化一个HelloService , 直接调用java服务端的方法</p>
<p>服务端实现HelloService , 提供服务</p>
<p>只支持java单语言之间的调用 ,  如果要支持跨语言调用 , 需要由IDL来生成Stub</p>
<p>和消息队列的共同点: 高性能网络传输 , 序列化,反序列化, 服务发现</p>
<h1 id="底层执行原理"><a href="#底层执行原理" class="headerlink" title="底层执行原理"></a>底层执行原理</h1><p>客户端实例化helloService ,  实例化出一个代理类,也称为Stub , 这个Stub代替客户端执行远程请求</p>
<p>这个作业中的Stub在编译阶段生成 ,  有的是在运行时动态生成</p>
<p>代理类代替发出请求,  带上方法名和所有参数</p>
<p>服务端解析请求 , 找到对应的方法 , 传入参数进行调用 , </p>
<p>得到结果后,通过服务端的Stub代替返回远程请求</p>
<p>假设有多个服务端提供服务 , 客户端不知道该请求哪个地址 ,  因此还需要实现一个NamingService , 相当于注册中心 , 提供的功能 : 服务端注册 , 客户端获取服务(地址)</p>
<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p>RPC框架门面类 , RPCAccessPoint , 唯一对外提供接口的类 , 目前仅有 注册实例和获取实例 , 和一个startServer启动服务端常驻进程</p>
<p>NameService , 注册服务和查询服务地址</p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>双方遵从同一个接口约定 , 比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public interface HelloService &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    String hello(String name);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>


<p>//查找到服务的远程地址<br>URI uri = nameService.lookupService(serviceName);<br>//获取代理类(Stub)<br>HelloService helloService = rpcAccessPoint.getRemoteService(uri, HelloService.class);<br>//执行远程请求 ,像本地服务一样调用 ( 最终目的)<br>String response = helloService.hello(name);<br>logger.info(“ 收到响应: {}.”, response);</p>
<p>服务端实现接口<br>public class HelloServiceImpl implements HelloService {<br>    @Override<br>    public String hello(String name) {<br>        String ret = “Hello, “ + name;<br>        return ret;<br>    }<br>}</p>
<p>//启动服务监听<br>rpcAccessPoint.startServer();<br>//注册接口具体实现<br>URI uri = rpcAccessPoint.addServiceProvider(helloService, HelloService.class);<br>//注册服务 , 提供客户端发现<br>nameService.registerService(serviceName, uri);</p>
<p>//序列化相关的门面类 ,  存放着多个 Serializer , 不同对象类型的序列化实现不一样 , 有两个map获取对应的实现类<br>public class SerializeSupport {<br>private static Map&lt;Class<?>/* 序列化对象类型 */, Serializer<?>/* 序列化实现 <em>/&gt; serializerMap = new HashMap&lt;&gt;();<br>    private static Map&lt;Byte/</em> 序列化实现类型 <em>/, Class&lt;?&gt;/</em> 序列化对象类型 */&gt; typeMap = new HashMap&lt;&gt;();<br>    public static  <E> E parse(byte [] buffer) {<br>        // …<br>    }<br>    public static <E> byte [] serialize(E  entry) {<br>        // …<br>    }<br>}</p>
<p>// 序列化<br>MyClass myClassObject = new MyClass();<br>byte [] bytes = SerializeSupport.serialize(myClassObject);<br>// 反序列化<br>MyClass myClassObject1 = SerializeSupport.parse(bytes);</p>
<p>//Serializer接口</p>
<p>public interface Serializer<T> {<br>    /**<br>     * 计算对象序列化后的长度，主要用于申请存放序列化数据的字节数组<br>     * @param entry 待序列化的对象<br>     * @return 对象序列化后的长度<br>     */<br>    int size(T entry);</p>
<pre><code>/**
 * 序列化对象。将给定的对象序列化成字节数组
 * @param entry 待序列化的对象
 * @param bytes 存放序列化数据的字节数组
 * @param offset 数组的偏移量，从这个位置开始写入序列化数据
 * @param length 对象序列化后的长度，也就是{@link Serializer#size(java.lang.Object)}方法的返回值。
 */
void serialize(T entry, byte[] bytes, int offset, int length);

/**
 * 反序列化对象
 * @param bytes 存放序列化数据的字节数组
 * @param offset 数组的偏移量，从这个位置开始写入序列化数据
 * @param length 对象序列化后的长度
 * @return 反序列化之后生成的对象
 */
T parse(byte[] bytes, int offset, int length);

/**
 * 用一个字节标识对象类型，每种类型的数据应该具有不同的类型值
 */
byte type();

/**
 * 返回序列化对象类型的 Class 对象。
 */
Class&lt;T&gt; getSerializeClass();</code></pre><p>}</p>
<p>//字符串序列化实现 , 统一UTF8<br>public class StringSerializer implements Serializer<String> {<br>    @Override<br>    public int size(String entry) {<br>        return entry.getBytes(StandardCharsets.UTF_8).length;<br>    }</p>
<pre><code>@Override
public void serialize(String entry, byte[] bytes, int offset, int length) {
    byte [] strBytes = entry.getBytes(StandardCharsets.UTF_8);
    System.arraycopy(strBytes, 0, bytes, offset, strBytes.length);
}

@Override
public String parse(byte[] bytes, int offset, int length) {
    return new String(bytes, offset, length, StandardCharsets.UTF_8);
}

@Override
public byte type() {
    return Types.TYPE_STRING;
}

@Override
public Class&lt;String&gt; getSerializeClass() {
    return String.class;
}</code></pre><p>}</p>
<h1 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h1><p>public interface Transport {<br>    /**<br>     * 发送请求命令<br>     * @param request 请求命令<br>     * @return 返回值是一个 Future，Future<br>     */<br>    CompletableFuture<Command> send(Command request);<br>}</p>
<p>通信格式定义 </p>
<p>public class Command {<br>    protected Header header;<br>    private byte [] payload;<br>    //…<br>}</p>
<p>public class Header {<br>    private int requestId;<br>    private int version;<br>    private int type;<br>    // …<br>}<br>public class ResponseHeader extends Header {<br>    private int code;<br>    private String error;<br>    // …<br>}</p>
<p>使用 netty发送请求</p>
<p>定义inFlightRequests结构 保存在途中的请求</p>
<p>异步通信时 , 背压机制的实现和存在的必要性 , 相当于令牌分发和回收 , 在InFlightRequests类中,用信号量(类似锁)实现?</p>
<p>@Override<br>public  CompletableFuture<Command> send(Command request) {<br>    // 构建返回值<br>    CompletableFuture<Command> completableFuture = new CompletableFuture&lt;&gt;();<br>    try {<br>        // 将在途请求放到 inFlightRequests 中<br>        inFlightRequests.put(new ResponseFuture(request.getHeader().getRequestId(), completableFuture));<br>        // 发送命令<br>        channel.writeAndFlush(request).addListener((ChannelFutureListener) channelFuture -&gt; {<br>            // 处理发送失败的情况<br>            if (!channelFuture.isSuccess()) {<br>                completableFuture.completeExceptionally(channelFuture.cause());<br>                channel.close();<br>            }<br>        });<br>    } catch (Throwable t) {<br>        // 处理发送异常<br>        inFlightRequests.remove(request.getHeader().getRequestId());<br>        completableFuture.completeExceptionally(t);<br>    }<br>    return completableFuture;</p>
<h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><p>这里是如何把响应返回给客户端上层的 ?     AbstractStub里阻塞wait了<br>通讯方式是阻塞还是非阻塞 ?   发送网络请求的过程是非阻塞的 , 但是wait响应是阻塞的 ,    如果多个线程同时请求 , 会由inflightRequest类进行请求数限制</p>
<p>Stub是怎么生成的<br>Stub职责是什么 , 做了什么</p>
<p>用依赖倒置原则解耦 , 不能直接依赖也不能第三方间接依赖(如工厂) ,  用Java的SPI注入 , 配置文件配置 , 具体代码ServiceSupport</p>
<h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><p>实现的单机版的注册中心 , 但可通过接口扩展成跨服务器的</p>
<p>NameService<br>LocalFileNameService<br>并发读写文件加锁 , 不能使用语言提供的锁(只能锁住进程内) , 使用系统提供的文件锁</p>
<p>RequestHandlerRegistry<br>把请求分发给对应的handler 处理完后返回响应给客户端<br>RpcRequestHandler 这个框架的核心 (注册 RPC 服务和处理客户端 RPC 请求)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">@Override</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">public Command handle(Command requestCommand) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    Header header &#x3D; requestCommand.getHeader();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 从 payload 中反序列化 RpcRequest</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    RpcRequest rpcRequest &#x3D; SerializeSupport.parse(requestCommand.getPayload());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 查找所有已注册的服务提供方，寻找 rpcRequest 中需要的服务</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    Object serviceProvider &#x3D; serviceProviders.get(rpcRequest.getInterfaceName());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 找到服务提供者，利用 Java 反射机制调用服务的对应方法</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    String arg &#x3D; SerializeSupport.parse(rpcRequest.getSerializedArguments());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    Method method &#x3D; serviceProvider.getClass().getMethod(rpcRequest.getMethodName(), String.class);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    String result &#x3D; (String ) method.invoke(serviceProvider, arg);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; 把结果封装成响应命令并返回</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    return new Command(new ResponseHeader(type(), header.getVersion(), header.getRequestId()), SerializeSupport.serialize(result));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><p>apple(win)键 + alt + b 可以从接口类跳转到实现类</p>
<p>##写一个json rpc请求序列化器<br>添加fastjson依赖</p>
<p>序列化:<br>1把RPCRequest类转换成json对象 , 属性 interfaceName , methodName , serializeArgs<br>2把json对象转换成 字符串 , 再转换成字节数组 , 赋值 , 结束 </p>
<p>de序列化:<br>1把字节数组转成字符串 , 把字符串转成json对象 , 把json对象转成rpcRequest类</p>
<p>直接json序列化整个object , 再de成object</p>
<h2 id="解除“服务接口只能有一个方法，并且这个方法只能有一个参数，参数和返回值的类型都是-String-类型”这个限制"><a href="#解除“服务接口只能有一个方法，并且这个方法只能有一个参数，参数和返回值的类型都是-String-类型”这个限制" class="headerlink" title="解除“服务接口只能有一个方法，并且这个方法只能有一个参数，参数和返回值的类型都是 String 类型”这个限制"></a>解除“服务接口只能有一个方法，并且这个方法只能有一个参数，参数和返回值的类型都是 String 类型”这个限制</h2><p>1支持多个方法  , 完成</p>
<p>2支持多参数<br>java如何获取方法的参数列表?  method.getParameters();<br>遍历参数列表生成字符串<br>代理类里的参数序列化后是什么?<br>目前是把string参数序列化成字节数组 , 然后在server的handler里parse出arg<br>考虑使用参数数组[<br> [‘name’=&gt;123,’value’=&gt;’sd’,’type=&gt;’asd’]  , 不支持复杂数据类型 , 只支持string , int之类的<br> ],<br> 序列化成json数组, server parse出多个args </p>
<p>  定义Argument  name ,value,type (name可以不用) x<br>  在模板里向RpcRequest里传入Argument[]  x<br>  RpcRequest序列化成json , 传到server (完成)<br>  server端handler变化的地方: 遍历json字符串数组 , 生成每个参数对应的参数类 , 传入方法中 </p>
<p>完整文字描述整个执行过程 , 描述每个类的职责<br>画结构图<br>用其他语言实现一遍这个框架<br>描述一下动态代理的设计思想<br>singleton单例的注解实现 (@Singleton 的注解和获取单例的实现在 ServiceSupport)<br>实现一个支持JDBC协议 数据库的注册中心 (调用 RpcAccessPoint.getNameService() 方法，获取注册中心实例时，传入的参数就是 JDBC 的 URL，比如：“jdbc:mysql://127.0.0.1/mydb”;<br>                       不能修改 RPC 框架的源代码 ;<br>                       实现必须具有通用性，可以支持任意一种 JDBC 数据库。)</p>
<p>理解请求分发 / eventloop / reactor </p>
<figure class="highlight plain"><figcaption><span>RPC 框架的服务端处理客户端请求的业务逻辑中，我们分两层做了两次请求分发：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">在 RequestInvocation 类中，根据请求命令中的请求类型 (command.getHeader().getType())，分发到对应的请求处理器 RequestHandler 中；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">RpcRequestHandler 类中，根据 RPC 请求中的服务名，把 RPC 请求分发到对应的服务实现类的实例中去。</span></pre></td></tr></table></figure>

      </div>
      
      
      
    </div>
    

    
    
    
  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab1"><span class="nav-number">1.</span> <span class="nav-text">Lab1</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab2"><span class="nav-number">2.</span> <span class="nav-text">Lab2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#rpc-实现目标"><span class="nav-number">3.</span> <span class="nav-text">rpc 实现目标</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#底层执行原理"><span class="nav-number">4.</span> <span class="nav-text">底层执行原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#项目结构"><span class="nav-number">5.</span> <span class="nav-text">项目结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用方法"><span class="nav-number">6.</span> <span class="nav-text">使用方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网络通信"><span class="nav-number">7.</span> <span class="nav-text">网络通信</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#疑问"><span class="nav-number">8.</span> <span class="nav-text">疑问</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#服务端"><span class="nav-number">9.</span> <span class="nav-text">服务端</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#作业"><span class="nav-number">10.</span> <span class="nav-text">作业</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#解除“服务接口只能有一个方法，并且这个方法只能有一个参数，参数和返回值的类型都是-String-类型”这个限制"><span class="nav-number">10.1.</span> <span class="nav-text">解除“服务接口只能有一个方法，并且这个方法只能有一个参数，参数和返回值的类型都是 String 类型”这个限制</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">i hear and i forget, i see and i remember, i do and i understand.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/carlclone" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;carlclone" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://leetcode.com/carlclone" title="LeetCode → https:&#x2F;&#x2F;leetcode.com&#x2F;carlclone" rel="noopener" target="_blank"><i class="fa fa-fw fa-code"></i>LeetCode</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://learnku.com/blog/carlclone" title="LaravelChina → https:&#x2F;&#x2F;learnku.com&#x2F;blog&#x2F;carlclone" rel="noopener" target="_blank"><i class="fa fa-fw fa-instagram"></i>LaravelChina</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.jianshu.com/u/baea2de7cc1a" title="Jianshu → https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;baea2de7cc1a" rel="noopener" target="_blank"><i class="fa fa-fw fa-instagram"></i>Jianshu</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>



  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme: 'forest',
      logLevel: 3,
      flowchart: { curve: 'linear' },
      gantt: { axisFormat: '%m/%d/%Y' },
      sequence: { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

</body>
</html>
